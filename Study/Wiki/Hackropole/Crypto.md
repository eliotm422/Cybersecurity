
#  AdveRSArial Crypto RSA


Je viens de suivre un cours sur RSA mais je crois que j’ai oublié quelque chose. Il me semble que le prof parlait de deux trucs, mais je ne sais plus exactement quoi. Vous pouvez m’aider ?```

```python
┌──(kali㉿kali)-[/mnt/hgfs/Partage kali]
└─$ cat adversarial-crypto-infant.py output.txt 
from Crypto.Util.number import getStrongPrime, bytes_to_long, long_to_bytes

n = getStrongPrime(2048)
e = 2 ** 16 + 1

flag = bytes_to_long(open("output.txt", "rb").read())
c = pow(flag, e, n)

print(f"{n = }")
print(f"{e = }")
print(f"{c = }")
n = 22914764349697556963541692665721076425490063991574936243571428156261302060328685591556514036751777776065771167330244010708082147401402002914377904950080486799957005111360365028092884367373338454223568447811216200859660057226322801828334633020895296785582519610777820724907394060126570265818769159991752144783469338557691407102432786644694590118176582000965124360500257946304028767088296724907062561163478654995994205065812479605136088813543435895840276066683243706020091519857275219422246006137390619897086478975872204136389082598585864385077220265194919486850918633328368814287347732293510186569121425821644289329813
e = 65537
c = 11189917160698738647911433493693285101538131455035611550077950709107429331298329502327358588774261161674422351739941120882289954400477590502272629693853242116507000433761914368814656180874783594812260498542390500221519883099478550863172147588922341571443502449435143090576514228274833316274013491937919397957017546671325357027765817692571583998487352090789855980131184451611087822399088669705683765370510052781742383736278295296012267794429263720509724794426552010741678342838319060084074826713065120930332229122961216786019982413982114571551833129932338204333681414465713448112309599140515483842800125894387412148599                                                      
```

pip install pycryptodome

1. On choisit deux nombres premiers `p` et `q`.
2. Leur produit `n = p * q` est le module de chiffrement.
3. `phi(n) = (p - 1) × (q - 1)`.
4. On choisit `e` (dans notre cas `e = 2 ** 16 + 1`).
5. L’exposant de déchiffrement `d` est l’inverse de `e` modulo `phi(n)`.
6. On retrouve le message par : `pow(ciphertext, d, n)`.

Pour déchiffrer le message, il faut calculer `phi(n) = (p-1) * (q-1)` or, nous n’avons pas `p` et `q`.

Si l’on choisit `p = n` et `q = 1`, on se retrouve avec `phi(n) = 0`.

Comme `phi(n)` représente le nombre d’entiers premiers avec `n` et que `n` est premier, on trouve `phi(n) = n-1`.

```python
def rsa_decrypt(ciphertext, p, q, e):
    n = p * q
    phi = n - 1
    # Calculate the private exponent d
    d = pow(e, -1, phi)
    # Decrypt the message
    plaintext = pow(ciphertext, d, n)
    return long_to_bytes(plaintext)

print(rsa_decrypt(c, n, 1, e))
# Output: b'FCSC{d0bf88291bcd488f28a809c9ae79d53da9caefc85b3790f57615e61c70a45f3c}'
```

ou alors 

```python
from Crypto.Util.number import *

n = 22914764349697556963541692665721076425490063991574936243571428156261302060328685591556514036751777776065771167330244010708082147401402002914377904950080486799957005111360365028092884367373338454223568447811216200859660057226322801828334633020895296785582519610777820724907394060126570265818769159991752144783469338557691407102432786644694590118176582000965124360500257946304028767088296724907062561163478654995994205065812479605136088813543435895840276066683243706020091519857275219422246006137390619897086478975872204136389082598585864385077220265194919486850918633328368814287347732293510186569121425821644289329813
e = 65537
c = 11189917160698738647911433493693285101538131455035611550077950709107429331298329502327358588774261161674422351739941120882289954400477590502272629693853242116507000433761914368814656180874783594812260498542390500221519883099478550863172147588922341571443502449435143090576514228274833316274013491937919397957017546671325357027765817692571583998487352090789855980131184451611087822399088669705683765370510052781742383736278295296012267794429263720509724794426552010741678342838319060084074826713065120930332229122961216786019982413982114571551833129932338204333681414465713448112309599140515483842800125894387412148599

d = pow(e,-1,n-1) # Calcul de la clé privée

print(f"Le flag est : {long_to_bytes(pow(c,d,n)).decode()}")
```